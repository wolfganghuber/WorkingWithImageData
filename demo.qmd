---
title: '<a href="https://www.huber.embl.de/msmb/11-chap.html">Working with Image Data: </a>'
author: Wolfgang Huber
date: 2023-03-23
date-format: iso
format:
  revealjs: 
    theme: wh.scss
    logo: fig/ukraine.png
    transition: slide
    scrollable: true
    slide-number: c/t
    show-slide-number: all
    auto-stretch: false
    code-line-numbers: false
    code-copy: true
    code-link: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
execute: 
  echo: true
  warning: true
  error: false
  message: false
slide-level: 1
---

# Reading and displaying an image

<!--Notes on the YAML header:
 - auto-stretch is a huge source of grief for slide layout, see https://quarto.org/docs/presentations/revealjs/advanced.html - stretch
-->


```{r}
#| label: setup
#| echo: false
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE)
options(EBImage.display = "raster")
```

```{r}
#| label: read
library("EBImage")
idi = readImage("fig/Stamp_of_Ukraine_s1985.jpg")
display(idi)
```

# Algebraic computations 

```{r}
x = 1 - idi
display(x)
```

# Convert into a greyscale image

```{r}
idigr = Image(apply(idi, 1:2, mean)) 
display(idigr)
```

# Histogram

```{r}
hist(idigr)
```

# Algebraic computations 

```{r}
x = idigr * 2
display(x)
```

# Computations. An image is just an array 

```{r}
x = idigr ^ (1/3)
display(x)
```

# Thresholding

```{r}
x = idigr > quantile(idigr, prob = 0.25)
display(x)
```

# Transpose

```{r}
x = transpose(idi)
display(x)
```

# Rotate

```{r}
x = EBImage::rotate(idi, angle = 30)
display(x)
```

# Translate

```{r}
x = translate(idi, v = c(40, 70))
display(x)
```

# Flip: vertical reflection

```{r}
x = flip(idi)
display(x)
```

# Flop: horizontal reflection

```{r}
x = flop(idi)
display(x)
```

# Subsetting ('cropping')

```{r}
m = idi[800:1000, 420:560, ]
display(m)
```

# Stitching

```{r}
#| label: stitching1
#| echo: false
# This code chunk produces 4 individual tiles from the big initial image
ukraine_joewdavies = readImage("fig/ukraine_joewdavis.jpg")
sx = dim(ukraine_joewdavies)[1] / 2
sy = dim(ukraine_joewdavies)[2] / 2
tiles = list(ukraine_joewdavies[     1:sx    ,      1:sy, ], 
             ukraine_joewdavies[(sx+1):(2*sx),      1:sy, ], 
             ukraine_joewdavies[     1:sx    , (sy+1):(2*sy), ], 
             ukraine_joewdavies[(sx+1):(2*sx), (sy+1):(2*sy), ])
for (i in seq(along = tiles))
  writeImage(tiles[[i]], files = file.path("fig", sprintf("tile%03d.tiff", i)))
```
```{r}
#| label: stitching2
files = dir("fig", pattern = "^tile.*.tiff$", full.names = TRUE)
files
tiles = lapply(files, readImage) 
tiles[[1]]
```
```{r}
#| label: stitching3
#| layout-nrow: 1
#| fig-width:  !expr dim(ukraine_joewdavies)[1] / 2000
#| fig-height: !expr dim(ukraine_joewdavies)[2] / 2000
for (x in tiles) display(x)
```

<font size=-2>Thanks to Joe Davies (@joewdavies) for providing the image.</font>

```{r}
#| label: stitching4
sx = dim(tiles[[1]])[1]    # in practice, look at all tiles and do the gymnastics as necessary  
sy = dim(tiles[[1]])[2]    
combined = Image(NA_real_, dim = c(2 * sx, 2 * sy, 3), colormode = "color")
combined[     1:sx    ,      1:sy,     ] = tiles[[1]] 
combined[(sx+1):(2*sx),      1:sy,     ] = tiles[[2]] 
combined[     1:sx    , (sy+1):(2*sy), ] = tiles[[3]]
combined[(sx+1):(2*sx), (sy+1):(2*sy), ] = tiles[[4]]
display(combined)
```

# Segmentation, object feature extraction and classification

```{r}
#| label: grus1
grus = readImage("fig/Grus_grus_flocks.jpg")  # common crane (Kranich, кран). Source: Wikipedia
display(grus)
hist(grus)
fg = (grus[,,3] < 0.7) 
colorMode(fg) = "grayscale"
display(fg)
connCompID = bwlabel(fg)
display(colorLabels(connCompID))
```

Refine

```{r}
#| label: grus2
connCompSize = table(connCompID) 
connCompSize
hist(sqrt(connCompSize[-1]), breaks = 25)

bad = names(connCompSize)[connCompSize < 4]
bad
connCompID[ connCompID %in% as.integer(bad) ] = 0L
display(colorLabels(connCompID))
```

Count the number of birds

```{r}
#| label: numbirds
ids = unique(as.vector(connCompID)) |> setdiff("0")
length(ids)
```

Extract their coordinates (center of mass)


```{r}
#| label: coords
#| warning: false
library("dplyr")
birds = lapply(ids, function(i) {
  w = which(connCompID == as.integer(i), arr.ind = TRUE)
  tibble(
    x = mean(w[, 1]), 
    y = mean(w[, 2]), 
    size = nrow(w),
    phi = prcomp(w)$rotation[,1] |> (\(x) atan(x[1] / x[2]))())
}) |> bind_rows() 
birds[1:3, ]
```

```{r}
#| label: beyonce
#| echo: false
if (!("beyonce" %in% installed.packages()[, 1])) devtools::install_github("dill/beyonce")
```

```{r}
#| label: plotcoords
library("ggplot2")
library("beyonce")
ggplot(birds, aes(x = x, y = -y, col = sqrt(size))) + geom_point() +
  scale_color_gradientn(colors = beyonce_palette(72, 21, type = "continuous")) + coord_fixed()
```

# Optical flow analysis on a movie of bird murmuration

{{< video fig/eakKfY5aHmY.mp4 >}}

Use `ffmpeg` to extract the individual frames and store them as `png` files. Then use `EBImage::readImages` to read them into an array

```{sh}
#| label: ffmpegdisassemble
#| eval: FALSE
ffmpeg -ss 00:01:35 -t 00:01:57 -i fig/eakKfY5aHmY.mp4 fig/frames/murm-%04d.png
```

```{r}
#| label: readmovie1
#| eval: FALSE
library("EBImage")
frames = dir("fig/frames", full.names = TRUE) 
mov = readImage(frames)
dim(mov)
# [1] 1280  720    3  482
```


```{sh}
#| label: youtube-dl
#| eval: FALSE
% I first tried with
youtube-dl "https://www.youtube.com/watch?v=eakKfY5aHmY"  
% but this resulted in the error message also reported here https://stackoverflow.com/questions/75495800/error-unable-to-extract-uploader-id-youtube-discord-py
% So I followed the top-voted reply there, and ran 
python3 -m pip install --force-reinstall https://github.com/yt-dlp/yt-dlp/archive/master.tar.gz
yt-dlp "https://www.youtube.com/watch?v=eakKfY5aHmY"
% The movie is by dylan.winter@virgin.net
% It has 25 frames per second
%
% My backup location:
rsync -avz /Users/whuber/svnco/WorkingWithImageData/fig/eakKfY5aHmY.mp4 whuber@datatransfer.embl.de:/g/huber/www-huber/users/whuber/2304-Imaging-Data-in-R/resources/eakKfY5aHmY.mp4

% Some of the interesting segments are: 0:18-0:31, 1:21-1:33, 1:34-1:57, 2:10-2:32, 3:34-3:46
% I used the following
ffmpeg -ss 00:01:35 -t 00:01:57 -i fig/eakKfY5aHmY.mp4 fig/frames/murm-%04d.png
```

Read the frames (png files) produced by `ffmpeg`

```{r}
#| label: readmovie2
#| eval: FALSE
library("EBImage")
frames = dir("fig/frames", full.names = TRUE) 
frames = frames[1:500]
mov = readImage(frames)
print(object.size(mov), unit = "Gb")
movg = mov[,,1,] + mov[,,2,] + mov[,,3,]
colorMode(movg) = "grayscale"
```

Optical flow analysis: manually divide the image into overlapping squares on a grid, centered around `cx`, `cy`, of side length `2*epsilon`. Within each of them, for each time point, compute the flow vector `fvec`.

```{r}
#| label: Opticalflow
#| eval: FALSE
stride = 30
epsilon = 40
time = 1:dim(mov)[4]
# Instead of the 3 nested loops and fvec array, could also also use dplyr and tibble, depending on taste.  
cx = seq(from = epsilon, to = dim(movg)[1] - epsilon, by = stride)
cy = seq(from = epsilon, to = dim(movg)[2] - epsilon, by = stride)
fvec = array(NA_real_, dim = c(2, length(cx), length(cy), length(time) - 1))
for(it in seq_len(length(time) - 1)) {
  im1 = movg[, , time[it]    ]
  im2 = movg[, , time[it] + 1]
  for(ix in seq(along = cx)) {
    sx = (cx[ix] - epsilon + 1):(cx[ix] + epsilon)
    for(iy in seq(along = cy)) {
      sy = (cy[iy] - epsilon + 1):(cy[iy] + epsilon)
      f1 = imagefx::xcorr3d(im1[ sx, sy], im2[ sx, sy])
      fvec[, ix, iy, it] = f1$max.shifts
    }
  }
}
```

Save each frame as a PNG.

```{r}
#| label: Saveopticalflow
#| eval: FALSE
scala = 3
for(it in seq_len(length(time) - 1)) {
  png(file.path("fig", "opticalflow", sprintf("murm-%04d.png", it)), width = dim(mov)[1], height = dim(mov)[2], units = "px") 
  display(mov[,,,time[it]], method = "raster")
  for(ix in seq(along = cx)) 
    for(iy in seq(along = cy)) 
      if (any(fvec[, ix, iy, it] != 0))
        arrows(x0 = cx[ix], x1 = cx[ix] + scala * fvec[1, ix, iy, it], 
               y0 = cy[iy], y1 = cy[iy] + scala * fvec[2, ix, iy, it], 
               col = "#FFDD00", lwd = 2, length = 0.04)
  dev.off()
}
```

Assemble into a movie using `ffmpeg`.
```{sh}
#| label: ffmpegassemble
#| eval: FALSE
ffmpeg -framerate 12 -pattern_type glob -i 'fig/frames/opticalflow-*.png' -c:v libx264 -pix_fmt yuv420p fig/murmuration-oflow.mp4 
```
