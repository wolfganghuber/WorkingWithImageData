---
title: '<a href="https://www.huber.embl.de/msmb/11-chap.html">Working with Image Data: </a>'
author: Wolfgang Huber
date: 2023-03-23
date-format: iso
format:
  revealjs: 
    theme: wh.scss
    logo: fig/ukraine.png
    transition: slide
    scrollable: true
    slide-number: c/t
    show-slide-number: all
    auto-stretch: false
    code-line-numbers: false
    code-copy: true
    code-link: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
execute: 
  echo: true
  warning: true
  error: false
  message: false
slide-level: 1
---

# Reading and displaying an image

<!--Notes on the YAML header:
 - auto-stretch is a huge source of grief for slide layout, see https://quarto.org/docs/presentations/revealjs/advanced.html - stretch
-->


```{r}
#| label: setup
#| echo: false
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE)
options(EBImage.display = "raster")
```

```{r}
#| label: read
library("EBImage")
idi = readImage("fig/Stamp_of_Ukraine_s1985.jpg")
display(idi)
```

# Algebraic computations 

```{r}
x = 1 - idi
display(x)
```

# Convert into a greyscale image

```{r}
idigr = Image(apply(idi, 1:2, mean)) 
display(idigr)
```

# Histogram

```{r}
hist(idigr)
```

# Algebraic computations 

```{r}
x = idigr * 2
display(x)
```

# Computations. An image is just an array 

```{r}
x = idigr ^ (1/3)
display(x)
```

# Thresholding

```{r}
x = idigr > quantile(idigr, prob = 0.25)
display(x)
```

# Transpose

```{r}
x = transpose(idi)
display(x)
```

# Rotate

```{r}
x = EBImage::rotate(idi, angle = 30)
display(x)
```

# Translate

```{r}
x = translate(idi, v = c(40, 70))
display(x)
```

# Flip: vertical reflection

```{r}
x = flip(idi)
display(x)
```

# Flop: horizontal reflection

```{r}
x = flop(idi)
display(x)
```

# Subsetting ('cropping')

```{r}
m = idi[800:1000, 420:560, ]
display(m)
```

# Stitching

```{r}
#| label: stitching1
#| echo: false
# This code chunk produces 4 individual tiles from the big initial image
ukraine_joewdavies = readImage("fig/ukraine_joewdavis.jpg")
sx = dim(ukraine_joewdavies)[1] / 2
sy = dim(ukraine_joewdavies)[2] / 2
tiles = list(ukraine_joewdavies[     1:sx    ,      1:sy, ], 
             ukraine_joewdavies[(sx+1):(2*sx),      1:sy, ], 
             ukraine_joewdavies[     1:sx    , (sy+1):(2*sy), ], 
             ukraine_joewdavies[(sx+1):(2*sx), (sy+1):(2*sy), ])
for (i in seq(along = tiles))
  writeImage(tiles[[i]], files = file.path("fig", sprintf("tile%03d.tiff", i)))
```
```{r}
#| label: stitching2
files = dir("fig", pattern = "^tile.*.tiff$", full.names = TRUE)
files
tiles = lapply(files, readImage) 
tiles[[1]]
```
```{r}
#| label: stitching3
#| layout-nrow: 1
#| fig-width:  !expr dim(ukraine_joewdavies)[1] / 2000
#| fig-height: !expr dim(ukraine_joewdavies)[2] / 2000
for (x in tiles) display(x)
```

<font size=-2>Thanks to Joe Davies (@joewdavies) for providing the image.</font>

```{r}
#| label: stitching4
sx = dim(tiles[[1]])[1]    # in practice, look at all tiles and do the gymnastics as necessary  
sy = dim(tiles[[1]])[2]    
combined = Image(NA_real_, dim = c(2 * sx, 2 * sy, 3), colormode = "color")
combined[     1:sx    ,      1:sy,     ] = tiles[[1]] 
combined[(sx+1):(2*sx),      1:sy,     ] = tiles[[2]] 
combined[     1:sx    , (sy+1):(2*sy), ] = tiles[[3]]
combined[(sx+1):(2*sx), (sy+1):(2*sy), ] = tiles[[4]]
display(combined)
```

# Segmentation, object feature extraction and classification

```{r}
#| label: grus1
grus = readImage("fig/Grus_grus_flocks.jpg")  # common crane (Kranich, кран). Source: Wikipedia
display(grus)
hist(grus)
fg = (grus[,,3] < 0.7) 
colorMode(fg) = "grayscale"
display(fg)
connCompID = bwlabel(fg)
display(colorLabels(connCompID))
```

Refine

```{r}
#| label: grus2
connCompSize = table(connCompID) 
connCompSize
hist(sqrt(connCompSize[-1]), breaks = 25)

bad = names(connCompSize)[connCompSize < 4]
bad
connCompID[ connCompID %in% as.integer(bad) ] = 0L
display(colorLabels(connCompID))
```

Count the number of birds

```{r}
#| label: numbirds
birds = unique(as.vector(connCompID)) |> setdiff("0")
length(birds)
```

Extract their coordinates (center of mass)


```{r}
#| label: coords
library("dplyr")
centerOfMass = lapply(birds, function(b) {
  w = which(connCompID == as.integer(b), arr.ind = TRUE)
  tibble(x = mean(w[, 1]), y = mean(w[, 2]), size = nrow(w))
}) |> bind_rows() 
centerOfMass[1:3, ]
```

```{r}
#| label: beyonce
#| echo: false
if (!("beyonce" %in% installed.packages()[, 1])) devtools::install_github("dill/beyonce")
```

```{r}
#| label: plotcoords
library("ggplot2")
library("beyonce")
ggplot(centerOfMass, aes(x = x, y = -y, col = sqrt(size))) + geom_point() +
  scale_color_gradientn(colors = beyonce_palette(72, 21, type = "continuous")) +
  coord_fixed()
```
